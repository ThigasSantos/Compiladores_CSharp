USING using
ID System
SEMI ;
USING using
ID System
DOT .
ID Collections
DOT .
ID Generic
SEMI ;
USING using
ID System
DOT .
ID IO
SEMI ;
USING using
ID System
DOT .
ID Linq
SEMI ;
USING using
ID System
DOT .
ID Reflection
SEMI ;
USING using
ID System
DOT .
ID Text
SEMI ;
USING using
ID System
DOT .
ID Threading
DOT .
ID Tasks
SEMI ;
PRE_NULLABLE #nullable
ID enable
NAMESPACE namespace
ID ComplexCSharpExample
LBRACE {
LBRACKET [
ID AttributeUsage
LPAREN (
ID AttributeTargets
DOT .
ID All
RPAREN )
RBRACKET ]
PUBLIC public
CLASS class
ID CustomAttribute
COLON :
ID Attribute
LBRACE {
PUBLIC public
STRING string
ID Description
LBRACE {
GET get
SEMI ;
SET set
SEMI ;
RBRACE }
PUBLIC public
ID CustomAttribute
LPAREN (
STRING string
ID description
RPAREN )
LAMBDA =>
ID Description
ASSIGN =
ID description
SEMI ;
RBRACE }
PUBLIC public
ENUM enum
ID Status
LBRACE {
ID Active
COMMA ,
ID Inactive
COMMA ,
ID Pending
RBRACE }
PUBLIC public
INTERFACE interface
ID IProcessable
LBRACE {
VOID void
ID Process
LPAREN (
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
DELEGATE delegate
INT int
ID MathOperation
LPAREN (
INT int
ID x
COMMA ,
INT int
ID y
RPAREN )
SEMI ;
PUBLIC public
STRUCT struct
ID Coordinates
LBRACE {
PUBLIC public
DOUBLE double
ID X
COMMA ,
ID Y
SEMI ;
PUBLIC public
ID Coordinates
LPAREN (
DOUBLE double
ID x
COMMA ,
DOUBLE double
ID y
RPAREN )
LAMBDA =>
LPAREN (
ID X
COMMA ,
ID Y
RPAREN )
ASSIGN =
LPAREN (
ID x
COMMA ,
ID y
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
ID record
ID Person
LPAREN (
STRING string
ID Name
COMMA ,
INT int
ID Age
RPAREN )
SEMI ;
PUBLIC public
CLASS class
ID Container
LT <
ID T
GT >
LBRACE {
PRIVATE private
ID List
LT <
ID T
GT >
ID items
ASSIGN =
NEW new
LPAREN (
RPAREN )
SEMI ;
PUBLIC public
VOID void
ID Add
LPAREN (
ID T
ID item
RPAREN )
LAMBDA =>
ID items
DOT .
ID Add
LPAREN (
ID item
RPAREN )
SEMI ;
PUBLIC public
ID T
THIS this
LBRACKET [
INT int
ID index
RBRACKET ]
LAMBDA =>
ID items
LBRACKET [
ID index
RBRACKET ]
SEMI ;
PUBLIC public
ID IEnumerable
LT <
ID T
GT >
ID GetAll
LPAREN (
RPAREN )
LAMBDA =>
ID items
SEMI ;
RBRACE }
PUBLIC public
CLASS class
ID SampleClass
COLON :
ID IProcessable
LBRACE {
PUBLIC public
INT int
ID Id
LBRACE {
GET get
SEMI ;
SET set
SEMI ;
RBRACE }
PRIVATE private
STRING string
QUESTION ?
ID _name
SEMI ;
PUBLIC public
STRING string
ID Name
LBRACE {
GET get
LAMBDA =>
ID _name
NULL_COALESCE ??
LITERAL_STRING "Unnamed"
SEMI ;
SET set
LAMBDA =>
ID _name
ASSIGN =
VALUE value
SEMI ;
RBRACE }
PUBLIC public
EVENT event
ID EventHandler
QUESTION ?
ID OnProcessed
SEMI ;
PUBLIC public
STATIC static
ASYNC async
ID Task
LT <
STRING string
GT >
ID ReadFileAsync
LPAREN (
STRING string
ID path
RPAREN )
LBRACE {
USING using
ID StreamReader
ID reader
ASSIGN =
NEW new
LPAREN (
ID path
RPAREN )
SEMI ;
RETURN return
AWAIT await
ID reader
DOT .
ID ReadToEndAsync
LPAREN (
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
VOID void
ID Process
LPAREN (
RPAREN )
LBRACE {
ID OnProcessed
NULL_COND ?.
ID Invoke
LPAREN (
THIS this
COMMA ,
ID EventArgs
DOT .
ID Empty
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
LPAREN (
INT int
ID sum
COMMA ,
INT int
ID product
RPAREN )
ID Calculate
LPAREN (
INT int
ID a
COMMA ,
INT int
ID b
RPAREN )
LBRACE {
RETURN return
LPAREN (
ID a
PLUS +
ID b
COMMA ,
ID a
MULT *
ID b
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
VOID void
ID PatternExample
LPAREN (
OBJECT object
ID obj
RPAREN )
LBRACE {
SWITCH switch
LPAREN (
ID obj
RPAREN )
LBRACE {
CASE case
INT int
ID i
WHEN when
ID i
GT >
LITERAL_INTEGER 0
COLON :
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Positive integer: {i}"
RPAREN )
SEMI ;
BREAK break
SEMI ;
CASE case
STRING string
ID s
COLON :
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"String: {s}"
RPAREN )
SEMI ;
BREAK break
SEMI ;
CASE case
NULL null
COLON :
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "Null"
RPAREN )
SEMI ;
BREAK break
SEMI ;
KWDEFAULT default
COLON :
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "Other type"
RPAREN )
SEMI ;
BREAK break
SEMI ;
RBRACE }
RBRACE }
PUBLIC public
STRING string
ID GetInterpolated
LPAREN (
RPAREN )
LAMBDA =>
INTERPOLATED_LITERAL_STRING $"ID: {Id}, Name: {Name}"
SEMI ;
RBRACE }
PUBLIC public
STATIC static
CLASS class
ID Utilities
LBRACE {
PUBLIC public
STATIC static
VOID void
ID RunMathOperation
LPAREN (
ID MathOperation
ID op
RPAREN )
LBRACE {
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Result: {op(10, 5)}"
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
STATIC static
VOID void
ID ReflectProperties
LT <
ID T
GT >
LPAREN (
ID T
ID obj
RPAREN )
LBRACE {
FOREACH foreach
LPAREN (
VAR var
ID prop
IN in
TYPEOF typeof
LPAREN (
ID T
RPAREN )
DOT .
ID GetProperties
LPAREN (
RPAREN )
RPAREN )
LBRACE {
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"{prop.Name} = {prop.GetValue(obj)}"
RPAREN )
SEMI ;
RBRACE }
RBRACE }
PUBLIC public
STATIC static
UNSAFE unsafe
VOID void
ID UnsafeMethod
LPAREN (
RPAREN )
LBRACE {
INT int
VALUE value
ASSIGN =
LITERAL_INTEGER 42
SEMI ;
INT int
MULT *
ID ptr
ASSIGN =
BITAND &
VALUE value
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Pointer value: {*ptr}"
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
STATIC static
DYNAMIC dynamic
ID GetDynamicObject
LPAREN (
RPAREN )
LBRACE {
DYNAMIC dynamic
ID obj
ASSIGN =
NEW new
ID System
DOT .
ID Dynamic
DOT .
ID ExpandoObject
LPAREN (
RPAREN )
SEMI ;
ID obj
DOT .
ID Name
ASSIGN =
LITERAL_STRING "Dynamic Name"
SEMI ;
ID obj
DOT .
ID Age
ASSIGN =
LITERAL_INTEGER 30
SEMI ;
RETURN return
ID obj
SEMI ;
RBRACE }
PUBLIC public
STATIC static
ID IEnumerable
LT <
STRING string
GT >
ID FilterNames
LPAREN (
ID IEnumerable
LT <
STRING string
GT >
ID names
RPAREN )
LBRACE {
RETURN return
ID names
DOT .
ID Where
LPAREN (
ID n
LAMBDA =>
ID n
DOT .
ID Length
GT >
LITERAL_INTEGER 3
RPAREN )
DOT .
ID Select
LPAREN (
ID n
LAMBDA =>
ID n
DOT .
ID ToUpper
LPAREN (
RPAREN )
RPAREN )
SEMI ;
RBRACE }
PUBLIC public
STATIC static
VOID void
ID TryCatchExample
LPAREN (
RPAREN )
LBRACE {
TRY try
LBRACE {
INT int
ID x
ASSIGN =
INT int
DOT .
ID Parse
LPAREN (
LITERAL_STRING "abc"
RPAREN )
SEMI ;
RBRACE }
CATCH catch
LPAREN (
ID FormatException
ID ex
RPAREN )
LBRACE {
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Caught exception: {ex.Message}"
RPAREN )
SEMI ;
RBRACE }
FINALLY finally
LBRACE {
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "Finally block executed."
RPAREN )
SEMI ;
RBRACE }
RBRACE }
RBRACE }
CLASS class
ID Program
LBRACE {
STATIC static
ASYNC async
ID Task
ID Main
LPAREN (
RPAREN )
LBRACE {
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "==== Iniciando Execução ===="
RPAREN )
SEMI ;
ID Coordinates
ID coord
ASSIGN =
NEW new
LPAREN (
REAL_LITERAL 10.5d
COMMA ,
REAL_LITERAL 20.3D
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Coordenadas: X = {coord.X}, Y = {coord.Y}"
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Status: {Status.Active}"
RPAREN )
SEMI ;
VAR var
ID person
ASSIGN =
NEW new
ID Person
LPAREN (
LITERAL_STRING "Alice"
COMMA ,
LITERAL_INTEGER 25__21312LU
RPAREN )
SEMI ;
VAR var
ID container
ASSIGN =
NEW new
ID Container
LT <
ID Person
GT >
LPAREN (
RPAREN )
SEMI ;
ID container
DOT .
ID Add
LPAREN (
ID person
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
ID container
LBRACKET [
LITERAL_INTEGER 0
RBRACKET ]
RPAREN )
SEMI ;
VAR var
ID sample
ASSIGN =
NEW new
ID SampleClass
LBRACE {
ID Id
ASSIGN =
LITERAL_INTEGER 0
COMMA ,
ID Name
ASSIGN =
LITERAL_STRING "Test"
RBRACE }
SEMI ;
ID sample
DOT .
ID OnProcessed
PLUS +
ASSIGN =
LPAREN (
ID sender
COMMA ,
ID e
RPAREN )
LAMBDA =>
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "Processed event fired!"
RPAREN )
SEMI ;
ID sample
DOT .
ID Process
LPAREN (
RPAREN )
SEMI ;
ID sample
DOT .
ID PatternExample
LPAREN (
LITERAL_INTEGER 123
RPAREN )
SEMI ;
ID sample
DOT .
ID PatternExample
LPAREN (
LITERAL_STRING "hello"
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
ID sample
DOT .
ID GetInterpolated
LPAREN (
RPAREN )
RPAREN )
SEMI ;
VAR var
LPAREN (
ID sum
COMMA ,
ID product
RPAREN )
ASSIGN =
ID sample
DOT .
ID Calculate
LPAREN (
LITERAL_INTEGER 3
COMMA ,
LITERAL_INTEGER 4
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Sum: {sum}, Product: {product}"
RPAREN )
SEMI ;
ID Utilities
DOT .
ID RunMathOperation
LPAREN (
LPAREN (
ID x
COMMA ,
ID y
RPAREN )
LAMBDA =>
ID x
PLUS +
ID y
RPAREN )
SEMI ;
ID Utilities
DOT .
ID ReflectProperties
LPAREN (
ID person
RPAREN )
SEMI ;
DYNAMIC dynamic
ID dyn
ASSIGN =
ID Utilities
DOT .
ID GetDynamicObject
LPAREN (
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"{dyn.Name}, {dyn.Age}"
RPAREN )
SEMI ;
VAR var
ID names
ASSIGN =
NEW new
LBRACKET [
RBRACKET ]
LBRACE {
LITERAL_STRING "Ana"
COMMA ,
LITERAL_STRING "Bob"
COMMA ,
LITERAL_STRING "Charles"
COMMA ,
LITERAL_STRING "David"
RBRACE }
SEMI ;
FOREACH foreach
LPAREN (
VAR var
ID n
IN in
ID Utilities
DOT .
ID FilterNames
LPAREN (
ID names
RPAREN )
RPAREN )
ID Console
DOT .
ID WriteLine
LPAREN (
ID n
RPAREN )
SEMI ;
ID Utilities
DOT .
ID TryCatchExample
LPAREN (
RPAREN )
SEMI ;
STRING string
ID path
ASSIGN =
LITERAL_STRING "sample.txt"
SEMI ;
AWAIT await
ID File
DOT .
ID WriteAllTextAsync
LPAREN (
ID path
COMMA ,
LITERAL_STRING "Exemplo de conteúdo."
RPAREN )
SEMI ;
STRING string
ID content
ASSIGN =
AWAIT await
ID SampleClass
DOT .
ID ReadFileAsync
LPAREN (
ID path
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
INTERPOLATED_LITERAL_STRING $"Arquivo: {content}"
RPAREN )
SEMI ;
ID Console
DOT .
ID WriteLine
LPAREN (
LITERAL_STRING "==== Fim da Execução ===="
RPAREN )
SEMI ;
RBRACE }
RBRACE }
RBRACE }
